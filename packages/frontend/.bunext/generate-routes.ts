/**
 * Auto-generate routes and layouts from src/pages/
 * This script scans the pages directory and generates a TypeScript file
 * with all routes and layouts automatically discovered.
 */

import fs from "fs";
import path from "path";

interface RouteEntry {
  route: string;
  filePath: string;
  importName: string;
}

/**
 * Recursively scan a directory for page and layout files
 */
function scanDirectory(dir: string, baseDir: string, routes: RouteEntry[], layouts: RouteEntry[]): void {
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = path.relative(baseDir, fullPath);

    if (entry.isDirectory()) {
      // Recursively scan subdirectories
      scanDirectory(fullPath, baseDir, routes, layouts);
    } else if (entry.isFile()) {
      const ext = path.extname(entry.name);
      const basename = path.basename(entry.name, ext);

      // Only process .tsx and .jsx files
      if (ext !== ".tsx" && ext !== ".jsx") continue;

      // Skip non-page files
      if (basename !== "index" && basename !== "layout") continue;

      // Convert file path to route path
      const routePath = "/" + relativePath.replace(/\\/g, "/").replace(/\.(tsx|jsx)$/, "");

      // Generate a unique import name
      const importName = generateImportName(relativePath);

      // Relative import path from .bunext/routes.generated.ts
      const importPath = "../src/pages/" + relativePath.replace(/\\/g, "/").replace(/\.(tsx|jsx)$/, "");

      if (basename === "layout") {
        layouts.push({ route: routePath, filePath: importPath, importName });
      } else if (basename === "index") {
        routes.push({ route: routePath, filePath: importPath, importName });
      }
    }
  }
}

/**
 * Generate a valid TypeScript import name from a file path
 * Examples:
 *   index.tsx -> HomePage
 *   [id]/index.tsx -> IdPage
 *   [...route]/index.tsx -> CatchAllRoutePage
 *   [[...route]]/index.tsx -> OptionalCatchAllRoutePage
 *   dashboard/settings/index.tsx -> DashboardSettingsPage
 */
function generateImportName(filePath: string): string {
  const parts = filePath
    .replace(/\\/g, "/")
    .replace(/\.(tsx|jsx)$/, "")
    .split("/")
    .filter((p) => p !== "index");

  if (parts.length === 0) {
    return "HomePage";
  }

  const name = parts
    .map((part) => {
      // Handle optional catch-all routes like [[...route]] -> OptionalCatchAllRoute
      if (part.startsWith("[[...") && part.endsWith("]]")) {
        const param = part.slice(5, -2); // Remove "[[..." and "]]"
        return "OptionalCatchAll" + param.charAt(0).toUpperCase() + param.slice(1);
      }
      // Handle catch-all routes like [...route] -> CatchAllRoute
      if (part.startsWith("[...") && part.endsWith("]")) {
        const param = part.slice(4, -1); // Remove "[..." and "]"
        return "CatchAll" + param.charAt(0).toUpperCase() + param.slice(1);
      }
      // Handle dynamic routes like [id] -> Id
      if (part.startsWith("[") && part.endsWith("]")) {
        const param = part.slice(1, -1);
        return param.charAt(0).toUpperCase() + param.slice(1);
      }
      // Capitalize first letter
      return part.charAt(0).toUpperCase() + part.slice(1);
    })
    .join("");

  // Add suffix based on file type
  if (filePath.includes("layout")) {
    return name + "Layout";
  }
  return name + "Page";
}

/**
 * Generate the routes.generated.ts file
 */
function generateRoutesFile(pagesDir: string, outputPath: string): void {
  const routes: RouteEntry[] = [];
  const layouts: RouteEntry[] = [];

  // Scan the pages directory
  scanDirectory(pagesDir, pagesDir, routes, layouts);

  // Sort for consistent output
  routes.sort((a, b) => a.route.localeCompare(b.route));
  layouts.sort((a, b) => a.route.localeCompare(b.route));

  // Generate the TypeScript file
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * AUTO-GENERATED FILE - DO NOT EDIT");
  lines.push(" * Generated by .bunext/generate-routes.ts");
  lines.push(" * Run `bun .bunext/generate-routes.ts` to regenerate");
  lines.push(" */");
  lines.push("");
  lines.push('import type React from "react";');
  lines.push("");

  // Import all pages
  if (routes.length > 0) {
    lines.push("// Page imports");
    for (const route of routes) {
      lines.push(`import ${route.importName} from "${route.filePath}";`);
    }
    lines.push("");
  }

  // Import all layouts
  if (layouts.length > 0) {
    lines.push("// Layout imports");
    for (const layout of layouts) {
      lines.push(`import ${layout.importName} from "${layout.filePath}";`);
    }
    lines.push("");
  }

  // Export routes map
  lines.push("// Routes map: route path -> component");
  lines.push("export const routes: Record<string, React.ComponentType> = {");
  for (const route of routes) {
    lines.push(`  "${route.route}": ${route.importName},`);
  }
  lines.push("};");
  lines.push("");

  // Export layouts map
  lines.push("// Layouts map: layout path -> component");
  lines.push("export const layouts: Record<string, React.ComponentType<{ children: React.ReactNode }>> = {");
  for (const layout of layouts) {
    lines.push(`  "${layout.route}": ${layout.importName},`);
  }
  lines.push("};");
  lines.push("");

  // Write the file
  fs.writeFileSync(outputPath, lines.join("\n"), "utf-8");

  console.log("âœ… Routes generated successfully!");
  console.log(`   Pages: ${routes.length}`);
  console.log(`   Layouts: ${layouts.length}`);
  console.log(`   Output: ${path.relative(process.cwd(), outputPath)}`);
}

// Run the generator
const pagesDir = path.join(import.meta.dir, "../src/pages");
const outputPath = path.join(import.meta.dir, "routes.generated.ts");

generateRoutesFile(pagesDir, outputPath);
